<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #1a3a3a; font-family: 'Segoe UI', sans-serif; }

        /* UIå±‚å…¨å±è¦†ç›–ï¼Œä¸»è¦ç”¨äºæ”¾ç½®ä¸­å¤®å¤§æ ‡é¢˜ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            display: flex; justify-content: center; 
            padding-top: 8vh; /* æ ‡é¢˜ä½ç½®ç¨å¾®é ä¸Š */
            box-sizing: border-box; 
            z-index: 10;
        }

        /* æ ‡é¢˜æ ·å¼ */
        h1 {
            font-family: 'Great Vibes', cursive; 
            color: #D4AF37; 
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6), 0 0 20px rgba(164, 0, 0, 0.4);
            font-weight: 400; 
            margin: 0; 
            font-size: 5rem; 
            text-align: center;
            opacity: 0.95;
            letter-spacing: 2px;
        }

        /* [ä¿®æ”¹] ç»Ÿä¸€çš„å·¦ä¸Šè§’ä¿¡æ¯å®¹å™¨ */
        #top-left-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€ */
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 8px; /* ä¸¤ä¸ªæç¤ºæ¡†ä¹‹é—´çš„é—´è· */
            align-items: flex-start;
        }

        /* [ä¿®æ”¹] çŠ¶æ€ä¿¡æ¯æ ·å¼ (åŠ è½½è¿›åº¦/èŠ‚æ—¥ç¥ç¦) */
        #status-message {
            color: rgba(255, 255, 255, 0.95);
            background: rgba(212, 175, 55, 0.15); /* ç¨å¾®å¸¦ç‚¹é‡‘è‰²èƒŒæ™¯ */
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.95rem;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        /* [ä¿®æ”¹] æ“ä½œæç¤ºæ ·å¼ (ç¨å¾®ä½è°ƒä¸€ç‚¹) */
        #controls-message {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            padding: 6px 10px;
            border-radius: 6px;
            backdrop-filter: blur(2px);
        }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <div id="top-left-container">
        <div id="status-message">æ­£åœ¨å‡†å¤‡ç¤¼ç‰©...</div>
        <div id="controls-message">ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾</div>
    </div>

    <div id="ui-layer">
        <h1>Merry Christmas Ryjj~</h1>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // ğŸ‘‡ ç…§ç‰‡è·¯å¾„
        // ==========================================
        const LOCAL_PHOTOS = [
            './photos/1.jpg',
            './photos/2.jpg',
            './photos/3.jpg',
            './photos/4.jpg',
            './photos/5.jpg',
            './photos/6.jpg',
            './photos/7.jpg',
            './photos/8.jpg',
            './photos/9.jpg'
        ];

        const CONFIG = {
            particleCount: 1400,  
            treeHeight: 45,       
            treeRadiusBase: 22,   
            colors: {
                matteGreen: 0x2E4B2B,
                metallicGold: 0xFFD700, 
                christmasRed: 0xD00000,
                warmLight: 0xFFF8E0 
            }
        };

        let scene, camera, renderer, composer, controls;
        let particles = [];
        let photoDataArray = []; 
        let group;
        let bloomPass;
        let borderMaterial;
        let snowSystem = null;

        function createSnowFlakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, 32, 32);
            context.font = '24px Arial';
            context.fillStyle = 'white'; 
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('â„ï¸', 16, 16);
            return new THREE.CanvasTexture(canvas);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a3a3a, 0.008); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 45); 
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); 
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.1;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;    
            controls.autoRotateSpeed = 1.0; 
            controls.minDistance = 20;     
            controls.maxDistance = 100;    
            controls.enablePan = false;    

            const ambientLight = new THREE.AmbientLight(CONFIG.colors.warmLight, 1.0); 
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(CONFIG.colors.metallicGold, 3.0);
            mainLight.position.set(20, 40, 50); 
            scene.add(mainLight);

            const frontLight = new THREE.PointLight(0xffffff, 1.5, 100);
            frontLight.position.set(0, 10, 40);
            scene.add(frontLight);

            // é›ªèŠ±
            const snowGeometry = new THREE.BufferGeometry();
            const snowVertices = [];
            for (let i = 0; i < 25000; i++) { 
                const x = THREE.MathUtils.randFloatSpread(400);
                const y = THREE.MathUtils.randFloatSpread(400);
                const z = THREE.MathUtils.randFloatSpread(300) - 50; 
                snowVertices.push(x, y, z);
            }
            snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowVertices, 3));
            
            const snowMaterial = new THREE.PointsMaterial({
                map: createSnowFlakeTexture(), 
                size: 1.8, 
                transparent: true, 
                opacity: 0.7,
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });
            snowSystem = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowSystem);

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; 
            bloomPass.strength = 1.0;
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            group = new THREE.Group();
            scene.add(group);

            borderMaterial = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.metallicGold, 
                roughness: 0.1, 
                metalness: 1.0, 
                emissive: 0xFFAA00, 
                emissiveIntensity: 0.4
            });

            createParticles();
            loadHardcodedPhotos();
            
            window.addEventListener('resize', onWindowResize);
        }

        function loadHardcodedPhotos() {
            if (LOCAL_PHOTOS.length === 0) {
                // [ä¿®æ”¹] æ›´æ–°å·¦ä¸Šè§’çš„çŠ¶æ€æ–‡å­—
                document.getElementById('status-message').innerText = "è¯·åœ¨ä»£ç ä¸­æ·»åŠ ç…§ç‰‡è·¯å¾„";
                return;
            }

            const loader = new THREE.TextureLoader();
            let loadedCount = 0;

            LOCAL_PHOTOS.forEach(src => {
                const img = new Image();
                img.crossOrigin = "Anonymous"; 
                img.src = src;
                
                img.onload = () => {
                    const aspectRatio = img.width / img.height;
                    loader.load(src, (texture) => {
                        loadedCount++;
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.minFilter = THREE.LinearFilter;
                        
                        photoDataArray.push({ texture: texture, ratio: aspectRatio });
                        // [ä¿®æ”¹] æ›´æ–°åŠ è½½è¿›åº¦
                        document.getElementById('status-message').innerText = `å·²æŒ‚ä¸Š ${loadedCount} / ${LOCAL_PHOTOS.length} ä¸ªå›å¿†`;
                        
                        if (loadedCount === LOCAL_PHOTOS.length) {
                             // [ä¿®æ”¹] åŠ è½½å®Œæˆï¼Œæ˜¾ç¤ºç¥ç¦è¯­
                             document.getElementById('status-message').innerText = "ğŸ„ åœ£è¯å¿«ä¹ ğŸ„";
                             updatePhotoSlots();
                             gsap.from(group.scale, { x:0, y:0, z:0, duration: 2, ease: "back.out(1.2)" });
                        }
                    });
                };
                img.onerror = () => document.getElementById('status-message').innerText = "å›¾ç‰‡åŠ è½½å¤±è´¥";
            });
        }

        function createParticles() {
            const geometries = {
                sphere: new THREE.SphereGeometry(0.7, 16, 16),
                box: new THREE.BoxGeometry(1.0, 1.0, 1.0),
                cane: new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8),
                star: new THREE.IcosahedronGeometry(0.8, 0),
                photoPlaceholder: new THREE.PlaneGeometry(1.5, 1.0) 
            };

            const materials = {
                gold: new THREE.MeshStandardMaterial({ color: CONFIG.colors.metallicGold, roughness: 0.2, metalness: 0.9 }),
                red: new THREE.MeshStandardMaterial({ color: CONFIG.colors.christmasRed, roughness: 0.4, metalness: 0.3 }),
                green: new THREE.MeshStandardMaterial({ color: CONFIG.colors.matteGreen, roughness: 0.8, metalness: 0.1 }),
                defaultPhoto: new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide })
            };

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const rand = Math.random();
                let isPhotoSlot = false;

                if (rand < 0.88) { 
                    const decoType = Math.random();
                    if (decoType < 0.3) mesh = new THREE.Mesh(geometries.sphere, Math.random()>0.5 ? materials.gold.clone() : materials.red.clone());
                    else if (decoType < 0.5) mesh = new THREE.Mesh(geometries.box, Math.random()>0.5 ? materials.red.clone() : materials.green.clone());
                    else if (decoType < 0.7) mesh = new THREE.Mesh(geometries.star, materials.gold.clone());
                    else mesh = new THREE.Mesh(geometries.cane, materials.red.clone());
                } else {
                    mesh = new THREE.Group();
                    const photoMesh = new THREE.Mesh(geometries.photoPlaceholder, materials.defaultPhoto.clone());
                    photoMesh.name = "photoLayer";
                    photoMesh.position.z = 0.05; 
                    
                    const borderMesh = new THREE.Mesh(geometries.photoPlaceholder, borderMaterial);
                    borderMesh.name = "borderLayer";
                    borderMesh.visible = false;
                    
                    mesh.add(borderMesh);
                    mesh.add(photoMesh);
                    isPhotoSlot = true;
                }

                const t = i / CONFIG.particleCount;
                const angle = t * Math.PI * 30; 
                const height = CONFIG.treeHeight * t - (CONFIG.treeHeight / 2); 
                
                let radius = (1 - t) * CONFIG.treeRadiusBase;
                if (isPhotoSlot) {
                    radius *= 1.3; 
                } else {
                    radius *= (0.8 + Math.random() * 0.4); 
                }

                const convergedPos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const lookAtPos = new THREE.Vector3(convergedPos.x * 2, convergedPos.y, convergedPos.z * 2);
                mesh.position.copy(convergedPos);
                mesh.lookAt(lookAtPos); 

                if (!isPhotoSlot) {
                     mesh.rotation.z += Math.random();
                     mesh.rotation.x += Math.random();
                }

                mesh.userData = { isPhotoSlot: isPhotoSlot, isShowingPhoto: false };
                group.add(mesh);
                particles.push(mesh);
            }
            group.position.y = -3; 
        }

        function updatePhotoSlots() {
            if (photoDataArray.length === 0) return;
            const slots = particles.filter(p => p.userData.isPhotoSlot);
            const shuffledSlots = slots.sort(() => 0.5 - Math.random());

            shuffledSlots.forEach((pGroup, i) => {
                const photoData = photoDataArray[i % photoDataArray.length];
                const tex = photoData.texture;
                const ratio = photoData.ratio;

                const photoMesh = pGroup.getObjectByName("photoLayer");
                const borderMesh = pGroup.getObjectByName("borderLayer");

                if (photoMesh.geometry) photoMesh.geometry.dispose();
                if (borderMesh.geometry) borderMesh.geometry.dispose();

                // [ä¿®æ”¹] å†æ¬¡ç¼©å°ç…§ç‰‡å°ºå¯¸ï¼šä» 3.8 æ”¹ä¸º 2.8
                const baseHeight = 2.4; 
                const photoWidth = baseHeight * ratio;
                const borderThickness = 0.25; 

                photoMesh.geometry = new THREE.PlaneGeometry(photoWidth, baseHeight);
                
                photoMesh.material = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide,
                    color: 0xbbbbbb 
                });
                
                borderMesh.geometry = new THREE.BoxGeometry(photoWidth + borderThickness, baseHeight + borderThickness, 0.2);
                borderMesh.visible = true;
                borderMesh.position.z = -0.1; 

                pGroup.userData.isShowingPhoto = true;
                
                pGroup.scale.set(0.1, 0.1, 0.1);
                gsap.to(pGroup.scale, { 
                    x: 1, y: 1, z: 1, 
                    duration: 1.2, 
                    delay: i * 0.05, 
                    ease: "elastic.out(1, 0.5)" 
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }

            if (snowSystem) {
                snowSystem.rotation.y += 0.001;
                const positions = snowSystem.geometry.attributes.position.array;
                for(let i = 1; i < positions.length; i+=3) {
                    positions[i] -= 0.3; 
                    if (positions[i] < -200) positions[i] = 200; 
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(new THREE.Vector2(window.innerWidth, window.innerHeight));
        }

        initThree();
        animate();
    </script>
</body>
</html>